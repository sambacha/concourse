// Code generated by counterfeiter. DO NOT EDIT.
package rcfakes

import (
	"crypto/tls"
	"sync"

	"github.com/concourse/concourse/fly/rc"
	"github.com/concourse/concourse/go-concourse/concourse"
)

type FakeTarget struct {
	CACertStub        func() string
	cACertMutex       sync.RWMutex
	cACertArgsForCall []struct {
	}
	cACertReturns struct {
		result1 string
	}
	cACertReturnsOnCall map[int]struct {
		result1 string
	}
	ClientStub        func() concourse.Client
	clientMutex       sync.RWMutex
	clientArgsForCall []struct {
	}
	clientReturns struct {
		result1 concourse.Client
	}
	clientReturnsOnCall map[int]struct {
		result1 concourse.Client
	}
	ClientCertPathStub        func() string
	clientCertPathMutex       sync.RWMutex
	clientCertPathArgsForCall []struct {
	}
	clientCertPathReturns struct {
		result1 string
	}
	clientCertPathReturnsOnCall map[int]struct {
		result1 string
	}
	ClientCertificateStub        func() []tls.Certificate
	clientCertificateMutex       sync.RWMutex
	clientCertificateArgsForCall []struct {
	}
	clientCertificateReturns struct {
		result1 []tls.Certificate
	}
	clientCertificateReturnsOnCall map[int]struct {
		result1 []tls.Certificate
	}
	ClientKeyPathStub        func() string
	clientKeyPathMutex       sync.RWMutex
	clientKeyPathArgsForCall []struct {
	}
	clientKeyPathReturns struct {
		result1 string
	}
	clientKeyPathReturnsOnCall map[int]struct {
		result1 string
	}
	FindTeamStub        func(string) (concourse.Team, error)
	findTeamMutex       sync.RWMutex
	findTeamArgsForCall []struct {
		arg1 string
	}
	findTeamReturns struct {
		result1 concourse.Team
		result2 error
	}
	findTeamReturnsOnCall map[int]struct {
		result1 concourse.Team
		result2 error
	}
	IsWorkerVersionCompatibleStub        func(string) (bool, error)
	isWorkerVersionCompatibleMutex       sync.RWMutex
	isWorkerVersionCompatibleArgsForCall []struct {
		arg1 string
	}
	isWorkerVersionCompatibleReturns struct {
		result1 bool
		result2 error
	}
	isWorkerVersionCompatibleReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	TLSConfigStub        func() *tls.Config
	tLSConfigMutex       sync.RWMutex
	tLSConfigArgsForCall []struct {
	}
	tLSConfigReturns struct {
		result1 *tls.Config
	}
	tLSConfigReturnsOnCall map[int]struct {
		result1 *tls.Config
	}
	TeamStub        func() concourse.Team
	teamMutex       sync.RWMutex
	teamArgsForCall []struct {
	}
	teamReturns struct {
		result1 concourse.Team
	}
	teamReturnsOnCall map[int]struct {
		result1 concourse.Team
	}
	TokenStub        func() *rc.TargetToken
	tokenMutex       sync.RWMutex
	tokenArgsForCall []struct {
	}
	tokenReturns struct {
		result1 *rc.TargetToken
	}
	tokenReturnsOnCall map[int]struct {
		result1 *rc.TargetToken
	}
	TokenAuthorizationStub        func() (string, bool)
	tokenAuthorizationMutex       sync.RWMutex
	tokenAuthorizationArgsForCall []struct {
	}
	tokenAuthorizationReturns struct {
		result1 string
		result2 bool
	}
	tokenAuthorizationReturnsOnCall map[int]struct {
		result1 string
		result2 bool
	}
	URLStub        func() string
	uRLMutex       sync.RWMutex
	uRLArgsForCall []struct {
	}
	uRLReturns struct {
		result1 string
	}
	uRLReturnsOnCall map[int]struct {
		result1 string
	}
	ValidateStub        func() error
	validateMutex       sync.RWMutex
	validateArgsForCall []struct {
	}
	validateReturns struct {
		result1 error
	}
	validateReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateWithWarningOnlyStub        func() error
	validateWithWarningOnlyMutex       sync.RWMutex
	validateWithWarningOnlyArgsForCall []struct {
	}
	validateWithWarningOnlyReturns struct {
		result1 error
	}
	validateWithWarningOnlyReturnsOnCall map[int]struct {
		result1 error
	}
	VersionStub        func() (string, error)
	versionMutex       sync.RWMutex
	versionArgsForCall []struct {
	}
	versionReturns struct {
		result1 string
		result2 error
	}
	versionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	WorkerVersionStub        func() (string, error)
	workerVersionMutex       sync.RWMutex
	workerVersionArgsForCall []struct {
	}
	workerVersionReturns struct {
		result1 string
		result2 error
	}
	workerVersionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTarget) CACert() string {
	fake.cACertMutex.Lock()
	ret, specificReturn := fake.cACertReturnsOnCall[len(fake.cACertArgsForCall)]
	fake.cACertArgsForCall = append(fake.cACertArgsForCall, struct {
	}{})
	fake.recordInvocation("CACert", []interface{}{})
	fake.cACertMutex.Unlock()
	if fake.CACertStub != nil {
		return fake.CACertStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cACertReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) CACertCallCount() int {
	fake.cACertMutex.RLock()
	defer fake.cACertMutex.RUnlock()
	return len(fake.cACertArgsForCall)
}

func (fake *FakeTarget) CACertCalls(stub func() string) {
	fake.cACertMutex.Lock()
	defer fake.cACertMutex.Unlock()
	fake.CACertStub = stub
}

func (fake *FakeTarget) CACertReturns(result1 string) {
	fake.cACertMutex.Lock()
	defer fake.cACertMutex.Unlock()
	fake.CACertStub = nil
	fake.cACertReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTarget) CACertReturnsOnCall(i int, result1 string) {
	fake.cACertMutex.Lock()
	defer fake.cACertMutex.Unlock()
	fake.CACertStub = nil
	if fake.cACertReturnsOnCall == nil {
		fake.cACertReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cACertReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTarget) Client() concourse.Client {
	fake.clientMutex.Lock()
	ret, specificReturn := fake.clientReturnsOnCall[len(fake.clientArgsForCall)]
	fake.clientArgsForCall = append(fake.clientArgsForCall, struct {
	}{})
	fake.recordInvocation("Client", []interface{}{})
	fake.clientMutex.Unlock()
	if fake.ClientStub != nil {
		return fake.ClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.clientReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) ClientCallCount() int {
	fake.clientMutex.RLock()
	defer fake.clientMutex.RUnlock()
	return len(fake.clientArgsForCall)
}

func (fake *FakeTarget) ClientCalls(stub func() concourse.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = stub
}

func (fake *FakeTarget) ClientReturns(result1 concourse.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = nil
	fake.clientReturns = struct {
		result1 concourse.Client
	}{result1}
}

func (fake *FakeTarget) ClientReturnsOnCall(i int, result1 concourse.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = nil
	if fake.clientReturnsOnCall == nil {
		fake.clientReturnsOnCall = make(map[int]struct {
			result1 concourse.Client
		})
	}
	fake.clientReturnsOnCall[i] = struct {
		result1 concourse.Client
	}{result1}
}

func (fake *FakeTarget) ClientCertPath() string {
	fake.clientCertPathMutex.Lock()
	ret, specificReturn := fake.clientCertPathReturnsOnCall[len(fake.clientCertPathArgsForCall)]
	fake.clientCertPathArgsForCall = append(fake.clientCertPathArgsForCall, struct {
	}{})
	fake.recordInvocation("ClientCertPath", []interface{}{})
	fake.clientCertPathMutex.Unlock()
	if fake.ClientCertPathStub != nil {
		return fake.ClientCertPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.clientCertPathReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) ClientCertPathCallCount() int {
	fake.clientCertPathMutex.RLock()
	defer fake.clientCertPathMutex.RUnlock()
	return len(fake.clientCertPathArgsForCall)
}

func (fake *FakeTarget) ClientCertPathCalls(stub func() string) {
	fake.clientCertPathMutex.Lock()
	defer fake.clientCertPathMutex.Unlock()
	fake.ClientCertPathStub = stub
}

func (fake *FakeTarget) ClientCertPathReturns(result1 string) {
	fake.clientCertPathMutex.Lock()
	defer fake.clientCertPathMutex.Unlock()
	fake.ClientCertPathStub = nil
	fake.clientCertPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTarget) ClientCertPathReturnsOnCall(i int, result1 string) {
	fake.clientCertPathMutex.Lock()
	defer fake.clientCertPathMutex.Unlock()
	fake.ClientCertPathStub = nil
	if fake.clientCertPathReturnsOnCall == nil {
		fake.clientCertPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.clientCertPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTarget) ClientCertificate() []tls.Certificate {
	fake.clientCertificateMutex.Lock()
	ret, specificReturn := fake.clientCertificateReturnsOnCall[len(fake.clientCertificateArgsForCall)]
	fake.clientCertificateArgsForCall = append(fake.clientCertificateArgsForCall, struct {
	}{})
	fake.recordInvocation("ClientCertificate", []interface{}{})
	fake.clientCertificateMutex.Unlock()
	if fake.ClientCertificateStub != nil {
		return fake.ClientCertificateStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.clientCertificateReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) ClientCertificateCallCount() int {
	fake.clientCertificateMutex.RLock()
	defer fake.clientCertificateMutex.RUnlock()
	return len(fake.clientCertificateArgsForCall)
}

func (fake *FakeTarget) ClientCertificateCalls(stub func() []tls.Certificate) {
	fake.clientCertificateMutex.Lock()
	defer fake.clientCertificateMutex.Unlock()
	fake.ClientCertificateStub = stub
}

func (fake *FakeTarget) ClientCertificateReturns(result1 []tls.Certificate) {
	fake.clientCertificateMutex.Lock()
	defer fake.clientCertificateMutex.Unlock()
	fake.ClientCertificateStub = nil
	fake.clientCertificateReturns = struct {
		result1 []tls.Certificate
	}{result1}
}

func (fake *FakeTarget) ClientCertificateReturnsOnCall(i int, result1 []tls.Certificate) {
	fake.clientCertificateMutex.Lock()
	defer fake.clientCertificateMutex.Unlock()
	fake.ClientCertificateStub = nil
	if fake.clientCertificateReturnsOnCall == nil {
		fake.clientCertificateReturnsOnCall = make(map[int]struct {
			result1 []tls.Certificate
		})
	}
	fake.clientCertificateReturnsOnCall[i] = struct {
		result1 []tls.Certificate
	}{result1}
}

func (fake *FakeTarget) ClientKeyPath() string {
	fake.clientKeyPathMutex.Lock()
	ret, specificReturn := fake.clientKeyPathReturnsOnCall[len(fake.clientKeyPathArgsForCall)]
	fake.clientKeyPathArgsForCall = append(fake.clientKeyPathArgsForCall, struct {
	}{})
	fake.recordInvocation("ClientKeyPath", []interface{}{})
	fake.clientKeyPathMutex.Unlock()
	if fake.ClientKeyPathStub != nil {
		return fake.ClientKeyPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.clientKeyPathReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) ClientKeyPathCallCount() int {
	fake.clientKeyPathMutex.RLock()
	defer fake.clientKeyPathMutex.RUnlock()
	return len(fake.clientKeyPathArgsForCall)
}

func (fake *FakeTarget) ClientKeyPathCalls(stub func() string) {
	fake.clientKeyPathMutex.Lock()
	defer fake.clientKeyPathMutex.Unlock()
	fake.ClientKeyPathStub = stub
}

func (fake *FakeTarget) ClientKeyPathReturns(result1 string) {
	fake.clientKeyPathMutex.Lock()
	defer fake.clientKeyPathMutex.Unlock()
	fake.ClientKeyPathStub = nil
	fake.clientKeyPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTarget) ClientKeyPathReturnsOnCall(i int, result1 string) {
	fake.clientKeyPathMutex.Lock()
	defer fake.clientKeyPathMutex.Unlock()
	fake.ClientKeyPathStub = nil
	if fake.clientKeyPathReturnsOnCall == nil {
		fake.clientKeyPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.clientKeyPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTarget) FindTeam(arg1 string) (concourse.Team, error) {
	fake.findTeamMutex.Lock()
	ret, specificReturn := fake.findTeamReturnsOnCall[len(fake.findTeamArgsForCall)]
	fake.findTeamArgsForCall = append(fake.findTeamArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindTeam", []interface{}{arg1})
	fake.findTeamMutex.Unlock()
	if fake.FindTeamStub != nil {
		return fake.FindTeamStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findTeamReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTarget) FindTeamCallCount() int {
	fake.findTeamMutex.RLock()
	defer fake.findTeamMutex.RUnlock()
	return len(fake.findTeamArgsForCall)
}

func (fake *FakeTarget) FindTeamCalls(stub func(string) (concourse.Team, error)) {
	fake.findTeamMutex.Lock()
	defer fake.findTeamMutex.Unlock()
	fake.FindTeamStub = stub
}

func (fake *FakeTarget) FindTeamArgsForCall(i int) string {
	fake.findTeamMutex.RLock()
	defer fake.findTeamMutex.RUnlock()
	argsForCall := fake.findTeamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTarget) FindTeamReturns(result1 concourse.Team, result2 error) {
	fake.findTeamMutex.Lock()
	defer fake.findTeamMutex.Unlock()
	fake.FindTeamStub = nil
	fake.findTeamReturns = struct {
		result1 concourse.Team
		result2 error
	}{result1, result2}
}

func (fake *FakeTarget) FindTeamReturnsOnCall(i int, result1 concourse.Team, result2 error) {
	fake.findTeamMutex.Lock()
	defer fake.findTeamMutex.Unlock()
	fake.FindTeamStub = nil
	if fake.findTeamReturnsOnCall == nil {
		fake.findTeamReturnsOnCall = make(map[int]struct {
			result1 concourse.Team
			result2 error
		})
	}
	fake.findTeamReturnsOnCall[i] = struct {
		result1 concourse.Team
		result2 error
	}{result1, result2}
}

func (fake *FakeTarget) IsWorkerVersionCompatible(arg1 string) (bool, error) {
	fake.isWorkerVersionCompatibleMutex.Lock()
	ret, specificReturn := fake.isWorkerVersionCompatibleReturnsOnCall[len(fake.isWorkerVersionCompatibleArgsForCall)]
	fake.isWorkerVersionCompatibleArgsForCall = append(fake.isWorkerVersionCompatibleArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("IsWorkerVersionCompatible", []interface{}{arg1})
	fake.isWorkerVersionCompatibleMutex.Unlock()
	if fake.IsWorkerVersionCompatibleStub != nil {
		return fake.IsWorkerVersionCompatibleStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.isWorkerVersionCompatibleReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTarget) IsWorkerVersionCompatibleCallCount() int {
	fake.isWorkerVersionCompatibleMutex.RLock()
	defer fake.isWorkerVersionCompatibleMutex.RUnlock()
	return len(fake.isWorkerVersionCompatibleArgsForCall)
}

func (fake *FakeTarget) IsWorkerVersionCompatibleCalls(stub func(string) (bool, error)) {
	fake.isWorkerVersionCompatibleMutex.Lock()
	defer fake.isWorkerVersionCompatibleMutex.Unlock()
	fake.IsWorkerVersionCompatibleStub = stub
}

func (fake *FakeTarget) IsWorkerVersionCompatibleArgsForCall(i int) string {
	fake.isWorkerVersionCompatibleMutex.RLock()
	defer fake.isWorkerVersionCompatibleMutex.RUnlock()
	argsForCall := fake.isWorkerVersionCompatibleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTarget) IsWorkerVersionCompatibleReturns(result1 bool, result2 error) {
	fake.isWorkerVersionCompatibleMutex.Lock()
	defer fake.isWorkerVersionCompatibleMutex.Unlock()
	fake.IsWorkerVersionCompatibleStub = nil
	fake.isWorkerVersionCompatibleReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTarget) IsWorkerVersionCompatibleReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isWorkerVersionCompatibleMutex.Lock()
	defer fake.isWorkerVersionCompatibleMutex.Unlock()
	fake.IsWorkerVersionCompatibleStub = nil
	if fake.isWorkerVersionCompatibleReturnsOnCall == nil {
		fake.isWorkerVersionCompatibleReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isWorkerVersionCompatibleReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTarget) TLSConfig() *tls.Config {
	fake.tLSConfigMutex.Lock()
	ret, specificReturn := fake.tLSConfigReturnsOnCall[len(fake.tLSConfigArgsForCall)]
	fake.tLSConfigArgsForCall = append(fake.tLSConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("TLSConfig", []interface{}{})
	fake.tLSConfigMutex.Unlock()
	if fake.TLSConfigStub != nil {
		return fake.TLSConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tLSConfigReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) TLSConfigCallCount() int {
	fake.tLSConfigMutex.RLock()
	defer fake.tLSConfigMutex.RUnlock()
	return len(fake.tLSConfigArgsForCall)
}

func (fake *FakeTarget) TLSConfigCalls(stub func() *tls.Config) {
	fake.tLSConfigMutex.Lock()
	defer fake.tLSConfigMutex.Unlock()
	fake.TLSConfigStub = stub
}

func (fake *FakeTarget) TLSConfigReturns(result1 *tls.Config) {
	fake.tLSConfigMutex.Lock()
	defer fake.tLSConfigMutex.Unlock()
	fake.TLSConfigStub = nil
	fake.tLSConfigReturns = struct {
		result1 *tls.Config
	}{result1}
}

func (fake *FakeTarget) TLSConfigReturnsOnCall(i int, result1 *tls.Config) {
	fake.tLSConfigMutex.Lock()
	defer fake.tLSConfigMutex.Unlock()
	fake.TLSConfigStub = nil
	if fake.tLSConfigReturnsOnCall == nil {
		fake.tLSConfigReturnsOnCall = make(map[int]struct {
			result1 *tls.Config
		})
	}
	fake.tLSConfigReturnsOnCall[i] = struct {
		result1 *tls.Config
	}{result1}
}

func (fake *FakeTarget) Team() concourse.Team {
	fake.teamMutex.Lock()
	ret, specificReturn := fake.teamReturnsOnCall[len(fake.teamArgsForCall)]
	fake.teamArgsForCall = append(fake.teamArgsForCall, struct {
	}{})
	fake.recordInvocation("Team", []interface{}{})
	fake.teamMutex.Unlock()
	if fake.TeamStub != nil {
		return fake.TeamStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) TeamCallCount() int {
	fake.teamMutex.RLock()
	defer fake.teamMutex.RUnlock()
	return len(fake.teamArgsForCall)
}

func (fake *FakeTarget) TeamCalls(stub func() concourse.Team) {
	fake.teamMutex.Lock()
	defer fake.teamMutex.Unlock()
	fake.TeamStub = stub
}

func (fake *FakeTarget) TeamReturns(result1 concourse.Team) {
	fake.teamMutex.Lock()
	defer fake.teamMutex.Unlock()
	fake.TeamStub = nil
	fake.teamReturns = struct {
		result1 concourse.Team
	}{result1}
}

func (fake *FakeTarget) TeamReturnsOnCall(i int, result1 concourse.Team) {
	fake.teamMutex.Lock()
	defer fake.teamMutex.Unlock()
	fake.TeamStub = nil
	if fake.teamReturnsOnCall == nil {
		fake.teamReturnsOnCall = make(map[int]struct {
			result1 concourse.Team
		})
	}
	fake.teamReturnsOnCall[i] = struct {
		result1 concourse.Team
	}{result1}
}

func (fake *FakeTarget) Token() *rc.TargetToken {
	fake.tokenMutex.Lock()
	ret, specificReturn := fake.tokenReturnsOnCall[len(fake.tokenArgsForCall)]
	fake.tokenArgsForCall = append(fake.tokenArgsForCall, struct {
	}{})
	fake.recordInvocation("Token", []interface{}{})
	fake.tokenMutex.Unlock()
	if fake.TokenStub != nil {
		return fake.TokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tokenReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) TokenCallCount() int {
	fake.tokenMutex.RLock()
	defer fake.tokenMutex.RUnlock()
	return len(fake.tokenArgsForCall)
}

func (fake *FakeTarget) TokenCalls(stub func() *rc.TargetToken) {
	fake.tokenMutex.Lock()
	defer fake.tokenMutex.Unlock()
	fake.TokenStub = stub
}

func (fake *FakeTarget) TokenReturns(result1 *rc.TargetToken) {
	fake.tokenMutex.Lock()
	defer fake.tokenMutex.Unlock()
	fake.TokenStub = nil
	fake.tokenReturns = struct {
		result1 *rc.TargetToken
	}{result1}
}

func (fake *FakeTarget) TokenReturnsOnCall(i int, result1 *rc.TargetToken) {
	fake.tokenMutex.Lock()
	defer fake.tokenMutex.Unlock()
	fake.TokenStub = nil
	if fake.tokenReturnsOnCall == nil {
		fake.tokenReturnsOnCall = make(map[int]struct {
			result1 *rc.TargetToken
		})
	}
	fake.tokenReturnsOnCall[i] = struct {
		result1 *rc.TargetToken
	}{result1}
}

func (fake *FakeTarget) TokenAuthorization() (string, bool) {
	fake.tokenAuthorizationMutex.Lock()
	ret, specificReturn := fake.tokenAuthorizationReturnsOnCall[len(fake.tokenAuthorizationArgsForCall)]
	fake.tokenAuthorizationArgsForCall = append(fake.tokenAuthorizationArgsForCall, struct {
	}{})
	fake.recordInvocation("TokenAuthorization", []interface{}{})
	fake.tokenAuthorizationMutex.Unlock()
	if fake.TokenAuthorizationStub != nil {
		return fake.TokenAuthorizationStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tokenAuthorizationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTarget) TokenAuthorizationCallCount() int {
	fake.tokenAuthorizationMutex.RLock()
	defer fake.tokenAuthorizationMutex.RUnlock()
	return len(fake.tokenAuthorizationArgsForCall)
}

func (fake *FakeTarget) TokenAuthorizationCalls(stub func() (string, bool)) {
	fake.tokenAuthorizationMutex.Lock()
	defer fake.tokenAuthorizationMutex.Unlock()
	fake.TokenAuthorizationStub = stub
}

func (fake *FakeTarget) TokenAuthorizationReturns(result1 string, result2 bool) {
	fake.tokenAuthorizationMutex.Lock()
	defer fake.tokenAuthorizationMutex.Unlock()
	fake.TokenAuthorizationStub = nil
	fake.tokenAuthorizationReturns = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeTarget) TokenAuthorizationReturnsOnCall(i int, result1 string, result2 bool) {
	fake.tokenAuthorizationMutex.Lock()
	defer fake.tokenAuthorizationMutex.Unlock()
	fake.TokenAuthorizationStub = nil
	if fake.tokenAuthorizationReturnsOnCall == nil {
		fake.tokenAuthorizationReturnsOnCall = make(map[int]struct {
			result1 string
			result2 bool
		})
	}
	fake.tokenAuthorizationReturnsOnCall[i] = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeTarget) URL() string {
	fake.uRLMutex.Lock()
	ret, specificReturn := fake.uRLReturnsOnCall[len(fake.uRLArgsForCall)]
	fake.uRLArgsForCall = append(fake.uRLArgsForCall, struct {
	}{})
	fake.recordInvocation("URL", []interface{}{})
	fake.uRLMutex.Unlock()
	if fake.URLStub != nil {
		return fake.URLStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uRLReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) URLCallCount() int {
	fake.uRLMutex.RLock()
	defer fake.uRLMutex.RUnlock()
	return len(fake.uRLArgsForCall)
}

func (fake *FakeTarget) URLCalls(stub func() string) {
	fake.uRLMutex.Lock()
	defer fake.uRLMutex.Unlock()
	fake.URLStub = stub
}

func (fake *FakeTarget) URLReturns(result1 string) {
	fake.uRLMutex.Lock()
	defer fake.uRLMutex.Unlock()
	fake.URLStub = nil
	fake.uRLReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTarget) URLReturnsOnCall(i int, result1 string) {
	fake.uRLMutex.Lock()
	defer fake.uRLMutex.Unlock()
	fake.URLStub = nil
	if fake.uRLReturnsOnCall == nil {
		fake.uRLReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uRLReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTarget) Validate() error {
	fake.validateMutex.Lock()
	ret, specificReturn := fake.validateReturnsOnCall[len(fake.validateArgsForCall)]
	fake.validateArgsForCall = append(fake.validateArgsForCall, struct {
	}{})
	fake.recordInvocation("Validate", []interface{}{})
	fake.validateMutex.Unlock()
	if fake.ValidateStub != nil {
		return fake.ValidateStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.validateReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) ValidateCallCount() int {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	return len(fake.validateArgsForCall)
}

func (fake *FakeTarget) ValidateCalls(stub func() error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = stub
}

func (fake *FakeTarget) ValidateReturns(result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	fake.validateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTarget) ValidateReturnsOnCall(i int, result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	if fake.validateReturnsOnCall == nil {
		fake.validateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTarget) ValidateWithWarningOnly() error {
	fake.validateWithWarningOnlyMutex.Lock()
	ret, specificReturn := fake.validateWithWarningOnlyReturnsOnCall[len(fake.validateWithWarningOnlyArgsForCall)]
	fake.validateWithWarningOnlyArgsForCall = append(fake.validateWithWarningOnlyArgsForCall, struct {
	}{})
	fake.recordInvocation("ValidateWithWarningOnly", []interface{}{})
	fake.validateWithWarningOnlyMutex.Unlock()
	if fake.ValidateWithWarningOnlyStub != nil {
		return fake.ValidateWithWarningOnlyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.validateWithWarningOnlyReturns
	return fakeReturns.result1
}

func (fake *FakeTarget) ValidateWithWarningOnlyCallCount() int {
	fake.validateWithWarningOnlyMutex.RLock()
	defer fake.validateWithWarningOnlyMutex.RUnlock()
	return len(fake.validateWithWarningOnlyArgsForCall)
}

func (fake *FakeTarget) ValidateWithWarningOnlyCalls(stub func() error) {
	fake.validateWithWarningOnlyMutex.Lock()
	defer fake.validateWithWarningOnlyMutex.Unlock()
	fake.ValidateWithWarningOnlyStub = stub
}

func (fake *FakeTarget) ValidateWithWarningOnlyReturns(result1 error) {
	fake.validateWithWarningOnlyMutex.Lock()
	defer fake.validateWithWarningOnlyMutex.Unlock()
	fake.ValidateWithWarningOnlyStub = nil
	fake.validateWithWarningOnlyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTarget) ValidateWithWarningOnlyReturnsOnCall(i int, result1 error) {
	fake.validateWithWarningOnlyMutex.Lock()
	defer fake.validateWithWarningOnlyMutex.Unlock()
	fake.ValidateWithWarningOnlyStub = nil
	if fake.validateWithWarningOnlyReturnsOnCall == nil {
		fake.validateWithWarningOnlyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateWithWarningOnlyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTarget) Version() (string, error) {
	fake.versionMutex.Lock()
	ret, specificReturn := fake.versionReturnsOnCall[len(fake.versionArgsForCall)]
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct {
	}{})
	fake.recordInvocation("Version", []interface{}{})
	fake.versionMutex.Unlock()
	if fake.VersionStub != nil {
		return fake.VersionStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.versionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTarget) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeTarget) VersionCalls(stub func() (string, error)) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = stub
}

func (fake *FakeTarget) VersionReturns(result1 string, result2 error) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeTarget) VersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	if fake.versionReturnsOnCall == nil {
		fake.versionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.versionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeTarget) WorkerVersion() (string, error) {
	fake.workerVersionMutex.Lock()
	ret, specificReturn := fake.workerVersionReturnsOnCall[len(fake.workerVersionArgsForCall)]
	fake.workerVersionArgsForCall = append(fake.workerVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("WorkerVersion", []interface{}{})
	fake.workerVersionMutex.Unlock()
	if fake.WorkerVersionStub != nil {
		return fake.WorkerVersionStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.workerVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTarget) WorkerVersionCallCount() int {
	fake.workerVersionMutex.RLock()
	defer fake.workerVersionMutex.RUnlock()
	return len(fake.workerVersionArgsForCall)
}

func (fake *FakeTarget) WorkerVersionCalls(stub func() (string, error)) {
	fake.workerVersionMutex.Lock()
	defer fake.workerVersionMutex.Unlock()
	fake.WorkerVersionStub = stub
}

func (fake *FakeTarget) WorkerVersionReturns(result1 string, result2 error) {
	fake.workerVersionMutex.Lock()
	defer fake.workerVersionMutex.Unlock()
	fake.WorkerVersionStub = nil
	fake.workerVersionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeTarget) WorkerVersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.workerVersionMutex.Lock()
	defer fake.workerVersionMutex.Unlock()
	fake.WorkerVersionStub = nil
	if fake.workerVersionReturnsOnCall == nil {
		fake.workerVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.workerVersionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeTarget) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cACertMutex.RLock()
	defer fake.cACertMutex.RUnlock()
	fake.clientMutex.RLock()
	defer fake.clientMutex.RUnlock()
	fake.clientCertPathMutex.RLock()
	defer fake.clientCertPathMutex.RUnlock()
	fake.clientCertificateMutex.RLock()
	defer fake.clientCertificateMutex.RUnlock()
	fake.clientKeyPathMutex.RLock()
	defer fake.clientKeyPathMutex.RUnlock()
	fake.findTeamMutex.RLock()
	defer fake.findTeamMutex.RUnlock()
	fake.isWorkerVersionCompatibleMutex.RLock()
	defer fake.isWorkerVersionCompatibleMutex.RUnlock()
	fake.tLSConfigMutex.RLock()
	defer fake.tLSConfigMutex.RUnlock()
	fake.teamMutex.RLock()
	defer fake.teamMutex.RUnlock()
	fake.tokenMutex.RLock()
	defer fake.tokenMutex.RUnlock()
	fake.tokenAuthorizationMutex.RLock()
	defer fake.tokenAuthorizationMutex.RUnlock()
	fake.uRLMutex.RLock()
	defer fake.uRLMutex.RUnlock()
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	fake.validateWithWarningOnlyMutex.RLock()
	defer fake.validateWithWarningOnlyMutex.RUnlock()
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	fake.workerVersionMutex.RLock()
	defer fake.workerVersionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTarget) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rc.Target = new(FakeTarget)
